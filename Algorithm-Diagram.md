# 算法图解笔记
## 常见数据结构
- 数组，链表，堆栈，散列表，队列
## 算法简介
- **二分查找**：一般而言,对于包含n个元素的列表,用二分查找最多需要$$log_{2}n$$步,而简单查找最多需要n步。
- 大O表示法的单位并不是秒，它比较的是算法的操作数，表示的是算法随着元素增多，算法运行时间的增加速度
- 常见的大O运行时间有O(log n), O(n), O(n * log n), O(n^2), O(n!)

## 选择排序
- 数组所存储的数据在内存中它们的内存地址是相连的，靠在一起的，因此添加新元素的速度会比较慢，因为系统需要找一块新的区域能同时把这些数据放在一起
- 而链表中的元素则可以存储在内存中的任何空闲的地方，因为链表中的元素包含了下一个元素的地址，从而使得一系列随机的内存地址串在一起。在链表
中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。
- 在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。
- 而数组则在添加元素效率比较低，而在随机地读取元素时，数组的效率很高。

## 递归
- 一般来说，如果使用循环,程序的性能可能更高；如果使用递归,程序可能更容易理解。如何选择要看什么对你来说更重要。
- 递归是函数自己调用自己，而这有可能会导致无限循环。因此，每个递归函数都有两部分:基线条件(base case)和递归条件(recursive case)。递归条件指的是函数可以调用自己的条件,而基线条件则指的是函数不再调用自己，退出递归的条件,从而避免形成无限循环。
```
def countdown(i):
    print(i)
    if i <= 0: (基线条件)
        return
    else: （递归条件）
        countdown(i-1)
```
- **调用栈**：调用另一个函数时,当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。此时这个调用函数占的内存和所用变量需要的内存处于栈顶，当这个调用函数执行结束后，调用函数的这个栈弹出，此时栈顶变为当前函数。
- **分而治之（divide and conquer）**：D&C并非可用于解决问题的算法,而是一种解决问题的思路。（1）找出基线条件,这种条件必须尽可能简单。（2）不断将问题分解(或者说缩小规模),直到符合基线条件。
- 编写一个递归函数来计算列表包含的元素数。
```
def get_length(arr):
    if len(arr) == 1:
        return 1
    else:
        return 1 + get_length(arr[1:])
```
- 找出列表中最大的数字。
```
def find_max(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        if arr[0] > find_max(arr[1:]):
            return arr[0]
        else:
            return find_max(arr[1:])
```
- D&C将问题逐步分解。使用D&C处理列表时,基线条件很可能是空数组或只包含一个元素的数组。
- 大O表示法中的常量有时候事关重大,这就是快速排序比合并排序快的原因所在。
- 比较简单查找和二分查找时,常量几乎无关紧要,因为列表很长时, O(log n)的速度比O(n)快得多。

## 散列表（hash table）
- 散列函数“将输入映射到数字”。（1）它必须是一致的。例如,假设你输入apple时得到的是4,那么每次输入apple时,得到的都必须为4。如果不是这样,散列表将毫无用处。（2）它应将不同的输入映射到不同的数字。例如,如果一个散列函数不管输入是什么都返回1,它就不是好的散列函数。最理想的情况是,将不同的输入映射到不同的数字。
    - 散列函数总是将同样的输入映射到相同的索引（比如数组的索引）。
    - 散列函数将不同的输入映射到不同的索引。（理想情况下）
    - 散列函数知道数组有多大,只返回有效的索引。
- 散列表也使用数组来存储数据,因此其获取元素的速度与数组一样快。
- Python提供的散列表实现为字典。
- 如果你将已投票者的姓名存储在列表中,这个函数的速度终将变得非常慢,因为它必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中,而散列表让你能够迅速知道来投票的人是否投过票。使用散列表来检查是否重复,速度非常快。
- 缓存的工作原理:网站将数据记住,而不再重新计算。缓存是一种常用的加速方式,所有大型网站都使用缓存,而缓存的数据则存储在散列表中!
- 散列表适合用于：（1）模拟映射关系;（2）防止重复;（3）缓存/记住数据,以免服务器再通过处理来生成它们。
- 散列函数存在着不同的输入映射到相同位置的情况，这种情况被称为冲突(collision)：给两个键分配的位置相同。处理冲突的方式很多,最简单的办法如下:如果两个键映射到了同一个位置,就在这个位置存储一个链表。
- 散列函数很重要。若散列函数将所有的键都映射到一个位置,则该位置的链表会非常的长，同时也浪费了散列表里其它的位置，而最理想的情况是,散列函数将键均匀地映射到散列表的不同位置。
- 如果散列表存储的链表很长,散列表的速度将急剧下降。然而,如果使用的散列函数很好,这些链表就不会很长!
- 在使用散列表时,避开最糟情况至关重要。为此,需要避免冲突。而要避免冲突,需要有：（1）较低的填装因子（散列表中所含的元素数/位置总数）;（2）良好的散列函数。
- 填装因子越低,发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7,就调整散列表的长度。

## 广度优先搜索（breadth-first search, BFS）
- 图是由节点（node）和边（edge）组成。
- 解决最短路径问题（shortest-path problem）的算法被称为广度优先搜索。广度优先搜索是一种用于图的查找算法,可帮助回答两类问题。（1）从节点A出发,有前往节点B的路径吗？（2）从节点A出发,前往节点B的哪条路径最短？
- 在广度优先搜索的执行过程中,搜索范围从起点开始逐渐向外延伸,即先检查一度关系,再检查二度关系。广度优先搜索不仅查找从A到B的路径,而且找到的是最短的路径。
- 队列的工作原理与现实生活中的队列完全相同。假设你与朋友一起在公交车站排队,如果你排在他前面,你将先上车。
- 队列类似于栈,你不能随机地访问队列中的元素。队列只支持两种操作:入队和出队。
- 队列是一种先进先出(First In First Out,FIFO)的数据结构,而栈是一种后进先出(Last In First Out,LIFO)的数据结构。
- 若节点之间的边是具有方向的，则称为有向图（directed graph）。若边没有方向，则是无向图（undirected graph），此时直接相连的节点互为邻居。
- 运行时间：如果你在你的整个人际关系网中搜索芒果销售商,就意味着你将沿每条边前行(记住,边是从一个人到另一个人的箭头或连接),因此运行时间至少为O(边数)。你还使用了一个队列,其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的,即为O(1),因此对每个人都这样做需要的总时间为O(人数)。所以,广度优先搜索的运行时间为O(人数 + 边数),这通常写作O(V + E),其中V为顶点(vertice)数,E为边数。
- 如果任务A依赖于任务B,在列表中任务A就必须在任务B后面。这被称为**拓扑排序**,使用它可根据图创建一个有序列表。
- 树是一种特殊的图,其中下面的节点没有指向上面的节点这样的情况。
